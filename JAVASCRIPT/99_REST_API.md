---
layout: post
title: REST API
author: haeran
date: 2025-05-12 21:07:00 +0900 
categories: [JAVASCRIPT]
banner:
  image:
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: [REST_API]
---

## REST API

REST는 **Representational State Transfer** 의 약자로, **웹의 장점을 최대한 활용할 수 있도록 고안된 아키텍처 스타일** 입니다.
REST API는 이 개념을 **HTTP 기반 웹 API 설계에 적용한 방식** 이에요.

## REST라는 말, 어디서 왔을까?

### REST의 창시자: 로이 필딩(Roy Fielding)

REST라는 개념은 2000년에 발표된 **로이 필딩(Roy Fielding)** 의 박사학위 논문에서 처음 등장했습니다.
그는 **HTTP의 공동 설계자**이며, **웹의 아키텍처 원리를 체계화한 인물** 이에요.

> 논문 제목: *Architectural Styles and the Design of Network-based Software Architectures*

이 논문에서 그는 웹이라는 분산 시스템이 **어떻게 일관되고 확장성 있게 설계될 수 있는지** 를 분석했고, 그 결과로 제안한 스타일이 바로 REST입니다.

### REST: Representational State Transfer

REST는 **Representational(표현) + State(상태) + Transfer(전달)** 의 합성어입니다.

* **Resource(자원)** 의 **표현(Representation)** 을
* **클라이언트와 서버 간에 전송(Transfer)** 하여
* 자원의 **상태(State)** 를 바꿀 수 있게 하자!

즉, **웹의 본질을 추상화한 이름**이에요. 처음부터 API를 위한 개념이 아니라 **웹 아키텍처의 이상적인 스타일**로 정의된 것입니다.

### 왜 REST가 중요한가?

당시에는 SOAP, XML-RPC 등 복잡한 웹서비스가 주류였고, 이들은 무겁고 융통성이 부족했습니다.
REST는 반대로:

* **HTTP만으로 가능하고**
* **URI + 메서드로 의미 전달이 명확하고**
* **캐싱, 무상태성, 계층 구조 등 웹의 장점을 극대화**할 수 있었기 때문에,

웹 시대에 어울리는 이상적인 설계 철학으로 주목받게 되었어요.

REST API는 **자원(Resource)** 중심으로 설계하며, 각 URL은 자원을 가리키고, 그 자원에 어떤 행동을 할지는 HTTP 메서드로 표현합니다.

> 쉽게 말해, **"HTTP 주소(URL) + HTTP 메서드(GET, POST, PUT, DELETE 등)"** 조합으로 서버 자원에 접근하거나 조작하는 방식입니다.

예를 들어:

* `GET /users` → 사용자 목록 조회
* `POST /users` → 사용자 생성
* `PUT /users/1` → id가 1인 사용자 수정
* `DELETE /users/1` → id가 1인 사용자 삭제

### "REST에서 자원(Resource)이라고 할 때 그게 정확히 뭔데?"

REST에서 자원이란 **고유한 URI로 식별할 수 있는 '데이터 대상'** 입니다.
단순히 '파일'이나 '문서'가 아니라, **웹에서 다룰 수 있는 모든 개념적인 것들** 을 자원이라고 봅니다.

| 자원 이름     | URI 예시              | 설명                          |
| --------- | ------------------- | --------------------------- |
| 사용자 목록    | `/users`            | 전체 사용자 집합                   |
| 특정 사용자    | `/users/1`          | id가 1인 사용자                  |
| 게시글       | `/posts/45`         | 45번 게시글                     |
| 특정 상품 이미지 | `/products/3/image` | 3번 상품의 이미지                  |
| 로그인 상태    | `/session`          | 현재 사용자 세션 (논리적 개념도 자원으로 간주) |

**즉, 자원이란 ‘이름 붙일 수 있고 고유하게 식별할 수 있는 대상’** 입니다.

### 중요한 건 "무엇"이 아니라 "식별 가능한가"

사용자, 게시글 같은 **물리적인 데이터** 뿐 아니라, 장바구니, 검색 결과, 세션 정보 같은 **논리적 개념** 도 자원으로 볼 수 있어요.

**핵심은 URI로 표현될 수 있는가?**  
REST는 “/로 자원을 명확하게 지칭”하는 구조를 권장합니다.

### 자원의 상태(Representation)는 JSON 같은 것으로 표현

REST에서 자원은 항상 “상태(데이터)”를 갖고 있어요.
그리고 이 상태는 클라이언트와 서버가 주고받을 수 있게 **JSON, XML, HTML 등으로 표현**됩니다.

예:
`GET /users/1` 요청 →

```json
{
  "id": 1,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

> 이 JSON은 ‘/users/1’이라는 자원의 현재 상태(Representation)를 표현한 것!

* 자원이란: **고유한 URI로 식별 가능한 모든 것**
* 물리적, 논리적 데이터 모두 포함됨
* **자체적으로 "이름 붙일 수 있고 식별 가능"하다면 자원**
* 그 자원의 상태는 JSON 같은 형식으로 표현되어 클라이언트와 주고받음

여기서 생각해 볼 것이 `POST /login` vs `POST /sessions`, RESTful 관점에서의 올바른 설계란?

## REST에서 ‘행위’를 URI에 넣으면 왜 안 되는 걸까?

### 흔한 예시: `POST /login` vs `POST /sessions`

많은 사람들이 로그인 API를 만들 때
`POST /login`
이렇게 짓습니다. 직관적이고 딱 봐도 "로그인하겠구나" 싶죠?

그런데 RESTful 설계 원칙에선 **이런 ‘행위 중심 URI’를 지양** 합니다.

## REST는 **자원 중심 설계(Resource-Oriented Design)**

REST에서 URI는 '무엇(자원)'을 지칭해야 하고, '어떻게(행위)'는 **HTTP 메서드**로 표현해야 합니다.

| REST 원칙  | 의미                |
| -------- | ----------------- |
| URI      | **자원을 나타냄 (무엇)**  |
| HTTP 메서드 | **행동을 나타냄 (어떻게)** |

### 그래서 올바른 예: `POST /sessions`

* 여기서 `sessions`는 **세션이라는 자원**을 의미해요.
* `POST`는 **새 세션(로그인 상태)을 생성한다**는 의미.
* `DELETE /sessions`은 **로그아웃**, 즉 세션을 종료하는 뜻이 됩니다.

이렇게 하면 **자원 중심 + 메서드 중심**의 RESTful 원칙을 잘 따르게 되는 거죠.

## 왜 이렇게 해야 RESTful한가?

### 1. **HTTP 메서드와 역할을 명확하게 분리**

`POST`는 **생성** , `GET`은 **조회** , `DELETE`는 **삭제** 처럼 정해진 동작이 있으므로, URI에 "create", "delete", "doLogin" 같은 동사를 넣으면 **중복되고 혼란스러워져요.**

### 2. **클라이언트가 추론하기 쉬움**

API를 처음 보는 클라이언트도 `DELETE /sessions`을 보면 "아 이건 로그아웃이구나" 추측이 가능, 반면 `GET /doLogout`, `POST /userDeleteAction`처럼 설계되면 전혀 직관적이지 않음.

**`DELETE /logout`이 더 직관적이지 않아?**

실제로 많은 분들이 DELETE /logout이 더 직관적인 것 같다고 느끼는 건 당연한 일이에요. 왜냐하면 자연어 관점에서는 "로그아웃 하다" → /logout이 더 명확하게 느껴지기 때문이죠. 하지만 REST의 설계 철학은 그보다 조금 더 구조적이고 추상적인 관점을 추구합니다.

그렇다고 /logout이 틀렸다는 뜻은 아니에요!

실무에서는 REST 철학과 사용자 직관 사이에서 절충이 필요한 경우가 많습니다.

인증 관련 API는 REST보다 RPC(Remote Procedure Call) 스타일로 설계되는 경우도 많아요.  
POST /login, POST /logout 같이 행위 중심 URI를 일부 허용하기도 합니다.  
OAuth2 같은 표준도 사실 엄격한 REST는 아닙니다.

> **RPC(Remote Procedure Call)**
>
> “원격지에 있는 함수(또는 메서드)를 마치 내 로컬 함수처럼 호출”하는 방식 (행위 중심 설계, 즉 RPC 스타일)  
> 즉, 서버에 있는 어떤 함수를 원격에서 호출하는 구조  
> /getUserById, /createOrder 같은 URI는 서버에서 실행할 '행위 이름'을 그대로 표현 -> 서버에서는 이름에 맞는 함수를 실행
>
> | 항목     | REST                | RPC                           |
> | ------ | ------------------- | ----------------------------- |
> | URI 의미 | 자원(명사)              | 함수/행위(동사)                     |
> | 예시     | `GET /users/1`      | `POST /getUserById`           |
> | 중심 개념  | **자원과 상태**          | **행위와 호출**                    |
> | 표현 방식  | `HTTP Method + URI` | 거의 대부분 `POST + 함수명 URI`       |
> | 메시지 설계 | 표준화된 구조 (HTTP 규약)   | 자유롭게 설계 가능 (JSON-RPC, gRPC 등) |

중요한 건 기술적으로 올바르다 vs 사용자에게 직관적이다 사이에서 균형을 잡는 거예요.

### 3. **표준 HTTP 캐시, 프록시 등과 호환성 유지**

HTTP는 URI+메서드를 기준으로 동작합니다. URI에 의미 없는 행동명이 들어가면 브라우저나 프록시에서 **불필요한 캐싱/우회** 문제가 생길 수 있어요.

예시를 들자면, 브라우저와 프록시는 GET 요청을 자동으로 캐시할 수 있는데 GET /doSomething처럼 부작용 있는 동작을 GET으로 보내면 프록시나 캐시가 그걸 안전한 요청이라고 착각해서 문제가 생길 수 있어요.

REST는 이런 문제를 예방하려고 의미 있는 메서드 + 명사형 URI를 권장합니다.

## 자주 하는 실수들

| 잘못된 URI          | 문제점                          |
| ---------------- | ---------------------------- |
| `/getUsers`      | URI에 동사가 들어감 → REST 원칙 위반    |
| `/createOrder`   | 행동 중심 설계 → HTTP 메서드가 있음에도 중복 |
| `/updateProfile` | PUT 요청이면 `/profile` 하나면 충분함  |

**올바른 예**는 다음과 같습니다:

| HTTP 메서드 | URI               | 의미          |
| -------- | ----------------- | ----------- |
| GET      | `/users`          | 사용자 목록 조회   |
| POST     | `/orders`         | 주문 생성       |
| PUT      | `/profile`        | 프로필 전체 수정   |
| DELETE   | `/cart/items/123` | 장바구니 아이템 삭제 |

### +질문! **‘자원’과 ‘엔드포인트’는 같은 개념인가요?**

비슷하지만 차이가 있어요. 자원은 '대상', 엔드포인트는 '접근 방식'

## REST API의 구성 요소는?

REST API를 설계할 땐 다음 구성 요소를 기본으로 삼아요:

| 요소                     | 설명                                      |
| ---------------------- | --------------------------------------- |
| **자원(Resource)**       | URI(예: `/posts/3`)로 식별되는 데이터            |
| **행동(Verb)**           | HTTP 메서드 (GET, POST, PUT, DELETE 등)     |
| **표현(Representation)** | JSON, XML 등의 포맷으로 데이터를 전달               |
| **상태 코드(Status Code)** | 요청에 대한 처리 결과 (예: 200 OK, 404 Not Found) |

## REST API 설계에서 중요한 점은?

REST API는 단순히 URL만 잘 만든다고 끝이 아닙니다. 다음 사항들을 꼭 고려해야 해요:

* **일관성 있는 URI**: 리소스 명사 중심 (`/users`, `/products/1`)
* **HTTP 메서드의 의미를 지킬 것**
* **적절한 상태 코드 반환**
* **에러 메시지는 친절하고 명확하게**
* **버전 관리**: `/api/v1/users`처럼 명시적 버전

> REST는 엄격한 규칙이라기보다 **권장 아키텍처 스타일**이에요. 상황에 따라 적절히 응용이 가능합니다.

## HTTP 요청 메서드 (Verbs) 요약 정리

| 메서드         | 설명                                   |
| ----------- | ------------------------------------ |
| **GET**     | 리소스를 조회합니다. (읽기 전용, 변경 없음)           |
| **POST**    | 리소스를 생성합니다.                          |
| **PUT**     | 리소스를 전체 수정합니다. (완전 대체)               |
| **PATCH**   | 리소스를 일부만 수정합니다.                      |
| **DELETE**  | 리소스를 삭제합니다.                          |
| **HEAD**    | GET과 동일하지만, 응답에 Body가 없음 (헤더 정보만)    |
| **OPTIONS** | 지원하는 HTTP 메서드 조회용 (CORS preflight 등) |

PUT과 PATCH, 둘 다 "수정"하는 메서드 맞지만 서로 다르게 사용돼요!

### **PUT**: **전체 자원을 대체 (Replace All)**

* 요청 바디에 **자원의 전체 상태** 가 들어감
* 서버는 해당 자원을 **완전히 덮어씌움**

```http
PUT /users/1
{
  "name": "홍길동",
  "email": "hong@example.com"
}
```

> 이 요청은 id=1인 사용자의 정보를 **이 데이터로 완전히 교체**함.
> 만약 기존에 "phone" 필드가 있었는데 여기 없다면, 그 필드는 삭제됨.

### **PATCH**: **일부 속성만 수정 (Partial Update)**

* 요청 바디에 **변경할 필드만** 포함
* 서버는 해당 필드만 업데이트하고 나머지는 유지

```http
PATCH /users/1
{
  "email": "new@example.com"
}
```

> 이 요청은 email만 바꾸고, 나머지(name 등)는 그대로 둠.

### 실제로 구현할 때도 다르게 동작할까?

**예. 다르게 구현해야 REST 원칙에 부합합니다.**

| 항목              | PUT                      | PATCH             |
| --------------- | ------------------------ | ----------------- |
| 데이터 구조          | 전체 자원                    | 변경 대상 필드만         |
| 구현 시 처리         | 모든 필드를 새로 저장 (덮어쓰기)      | 변경 필드만 찾아 업데이트    |
| 누락된 필드          | **삭제됨**                  | **유지됨**           |
| idempotent(멱등성) | 같은 요청 여러 번 보내도 상태 같음 | 보장 안 될 수도 있음 (주의) |

> ***멱등성*이란?**  
>
> 같은 요청을 여러 번 보내도 **결과가 변하지 않는 속성**.  
> `PUT`은 같은 데이터를 반복해서 보내도 서버 상태가 같지만,  
> `PATCH`는 내부 구현에 따라 다를 수 있음.

```http
// 기존 데이터
{
  "name": "혜란",
  "email": "maeran.dev.u@gmail.com",
  "phone": "010-1234-5678"
}
```

```http
// PUT 요청
PUT /users/1
{
  "name": "혜란"
}
→ 결과: email, phone 사라짐!
```

```http
// PATCH 요청
PATCH /users/1
{
  "name": "혜란"
}
→ 결과: name만 바뀌고 나머지는 그대로 유지!
```

### 그러면 PATCH가 항상 더 안전해 보이는데?

* PATCH는 **부분만 수정할 수 있어서 유연**하지만,
* **명확한 처리 규칙이 없어서 구현이 복잡**하거나 예외 처리 실수 가능성 있음
* 서버와 클라이언트가 **데이터 스키마를 공유**하고 있어야 안전하게 쓸 수 있어요

| 사용 상황               | 추천 메서드  |
| ------------------- | ------- |
| 전체 자원을 새로 저장        | `PUT`   |
| 일부 필드만 변경           | `PATCH` |
| 데이터 누락 시 삭제되어도 OK   | `PUT`   |
| 민감한 필드 유지하면서 일부만 수정 | `PATCH` |

### PATCH는 왜 멱등성(idempotency)을 보장하지 못하나요?

먼저 멱등성부터 다시 정의해 볼게요.

> **멱등성(Idempotency)**: 같은 요청을 여러 번 보내도 **결과가 같아야 한다**는 특성

- ✔ PUT은 멱등하다
  ```http
  PUT /users/1
  {
    "name": "홍길동",
    "email": "hong@example.com"
  }
  ```

  * 이 요청을 1번 보내든, 10번 보내든 **결과는 동일한 상태(지정된 전체 값으로 대체)** 가 됩니다.

- ✔ PATCH는 **상황에 따라 멱등하지 않을 수 있음**
  ```http
  PATCH /users/1
  {
    "loginCount": 1
  }
  ```

  * 이게 "loginCount를 **1로 설정하라**"는 의미면 멱등합니다.
  * 그런데 서버가 이걸 "loginCount에 1을 **추가하라**"로 해석하면?  
  → 여러 번 호출할수록 loginCount가 계속 증가 = 멱등하지 않음!

### 핵심 : PATCH는 **서버가 '어떻게 해석하느냐'에 따라** 동작이 달라집니다

PATCH는 명세상 **부분 변경의 의미**만 담고 있고, **"덮어쓸지", "합칠지", "계산할지"는 서버 구현에 따라 달라요.**  
이 때문에 **클라이언트는 PATCH가 멱등할 거라고 확신할 수 없습니다.**

## 실무에서는 PUT과 PATCH를 어떻게 나눠 쓰나요?

현업에서는 **두 가지 기준**을 따라 나누는 경우가 많아요.

### 기준 1: **수정 범위**

| 상황                          | 메서드     | 예 |
| --------------------------- | ------- |--------------------------- |
| 전체 데이터를 클라이언트가 알고 있고 보내는 경우 | `PUT`   | 사용자 전체 정보 입력 폼 |
| 일부 필드만 수정할 때                | `PATCH` | 프로필 사진만 바꾸는 기능 |

### 기준 2: **API의 목적이 명확할 때는 PUT, 복잡하고 유연한 수정이 필요할 땐 PATCH**

실무에서는 PATCH를 다음과 같이 사용합니다:

* 유저 설정처럼 **자주 바뀌는 다양한 속성들**
* IoT 장비나 게임 설정처럼 **부분 상태 변경이 잦은 데이터**
* RESTful하게 표현하기 어려운 **명령형 기능**
