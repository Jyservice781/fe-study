---
layout: post
title: 자바스크립트에서 함수
author: haeran
date: 2025-04-28 21:07:00 +0900 
categories: [JAVASCRIPT]
banner:
  image:
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: [Arrow_Function]
---

## 화살표 함수 등장 배경: 2010년대 초반의 자바스크립트 상황

2009년, **ECMAScript 5(ES5)**가 나왔지만 여전히 자바스크립트는 **낡고 번거로운 문법**이 많았습니다.

개발자들은 비동기 처리(`setTimeout`, `setInterval`, `event handler`) 같은 걸 할 때마다 **this** 문제에 부딪혔고, 함수형 프로그래밍을 적용하려 해도 `function` 키워드를 계속 써야 하니 코드가 **지저분하고 길어졌습니다.** 때문에 당시 페이스북, 구글, 트위터 같은 회사들이 **자바스크립트를 더 깔끔하고 강력하게 만들자** 고 목소리를 높였습니다.

특히 **CoffeeScript**라는 언어가 2010년에 등장하면서 `function` 대신 `(x) -> x * x` 같은 식으로 아주 간단하게 함수를 표현하는 방식 떄문에 사람들은 매우 놀랐다고 합니다. CoffeeScript가 인기를 끌자, **"자바스크립트도 이렇게 깔끔해져야 한다"**는 요구가 커졌습니다.

## TC39(자바스크립트 표준 위원회)의 논의

자바스크립트를 표준화하는 조직이 바로 **TC39** 입니다.

> 💡 TC39
>
> 자바스크립트(ECMAScript) 표준을 만들고 발전시키는 국제적인 위원회입니다.
>  
> 정식 명칭은 Technical Committee 39 (39번째 기술 위원회)로 ECMA International이라는 국제 표준화 기구 산하에 있습니다. 우리가 쓰는 JavaScript 문법 (예: let, const, 화살표 함수, async/await, optional chaining, BigInt...) 같은 걸 고안하고 승인하는 역할을 합니다.

2011~2012년 무렵, TC39 안에서 **짧은 함수 표현식** 을 추가하자는 제안(Proposal)이 나왔습니다. 초기 이름은 `Short Lambdas(짧은 람다)`였습니다.

> 💡 여기서 람다(lambda)는 "익명 함수"를 뜻하는 수학/컴퓨터 과학 용어입니다.

초기에는 `(a, b) -> a + b` 형태를 제안했어요. (`->`)

그런데 **자바스크립트 문법과 충돌**할 가능성 때문에, 방향이 약간 바뀌었습니다
(`-`와 `>`를 연결한 `->`는 이미 다른 곳(빼기 연산자, 비교 연산자 등)과 헷갈릴 수 있었어요.)

그래서 **`=` 기호를 넣어 `=>`**로 확정했습니다.

> `=`는 "대입(assignment)"을 의미하면서 "함수를 값처럼 다룬다"는 의미를 강화해주었고,  
> `>`는 "방향"을 뜻하니 **"인자 => 결과"** 흐름이 직관적이게 된 겁니다.

## ES6(ECMAScript 2015) 최종 채택

2015년에 **ES6** (혹은 ECMAScript 2015)가 공식 발표됐고, 이 때 드디어 **Arrow Function**이 표준 문법으로 채택되었습니다.

> ES6에서 도입된 주요 기능들
>
> - `let`, `const`
> - `class`
> - `Promise`
> - `module`
> - 그리고.. **Arrow Function(화살표 함수)**

## 덤: 화살표 함수는 완벽할까?

아니요. 화살표 함수도 단점은 있습니다.

- 생성자로 못 씁니다 (`new` 금지)
- 메서드로 사용하면 `this`가 이상하게 됩니다
- `arguments` 객체가 없습니다

그래서 여전히 **상황에 맞게** 메서드나 생성자는 일반 `function`, 콜백이나 짧은 함수는 `=>` 를 써야 해요.

## 화살표 함수 vs 일반 함수: 최적화(compilation)와 성능(performance) 차이

### 기본 개념 정리

자바스크립트 엔진(예: V8, SpiderMonkey, JavaScriptCore)은 코드를 실행할 때 이렇게 처리합니다:

1. **파싱 (Parsing)** → 소스코드를 AST(Abstract Syntax Tree)로 변환
2. **컴파일 (Compilation)** → 최적화 컴파일러(Ignition, TurboFan 등)가 실행할 수 있는 머신코드로 변환
3. **실행 (Execution)** → 실제 실행

이때, **함수**를 최적화하는 방식이 화살표 함수와 일반 함수에서 약간 다릅니다.

### 화살표 함수 vs 일반 함수: 최적화 차이

| 항목 | 일반 함수 (function) | 화살표 함수 (=>) |
|:---|:---|:---|
| **this 바인딩** | 런타임에 `this`를 결정 (동적) | 렉시컬 스코프에서 `this` 캡처 (정적) |
| **arguments 객체** | 기본 제공 (arguments 사용 가능) | 없음 (`...args` 필요) |
| **생성자(new)** | 가능 (new로 인스턴스 생성) | 불가 (TypeError 발생) |
| **scope 처리** | 실행 시 컨텍스트 생성 필요 | 바깥 스코프 재사용 |
| **최적화** | 상황에 따라 최적화가 어려울 수 있음 | 더 쉽게 최적화 가능 (불변성 유지) |

**(1) 일반 함수는 `this`를 동적으로 바인딩합니다**

- 누가 어떻게 호출했는지에 따라 `this`가 바뀝니다.  
일반 함수에서의 this는 함수가 어디서 정의되었는지가 아니라
어떻게 불렸는지(how it was called) 에 따라 값이 결정됩니다.  
그래서 자바스크립트 엔진은 매번 "이 함수는 누가 부르는 거지?"를 확인할 필요가 있어요... (동적)

    ```js
    function sayHi() {
    console.log(this.name);
    }

    const user = { name: 'Alice', hi: sayHi };
    const admin = { name: 'Bob', hi: sayHi };

    user.hi();   // 'Alice'
    admin.hi();  // 'Bob'
    ```

- 엔진은 함수 실행할 때마다 **컨텍스트(context)를 새로 생성**합니다.  
일반 함수(function)를 실행할 때마다, 새로운 저장공간을 만들고, this를 거기에 맞게 세팅하고, 실행이 끝나면 그 저장공간을 삭제합니다.  
이 과정은 항상 메모리와 계산 비용이 들어요.
    > 💡 컨텍스트 란?  
    > "함수가 실행될 때 필요한 정보(누가 호출했는지, 지역 변수, this 값 등)"를 저장하는 임시 저장소야.

- 동적 바인딩은 **코스트(비용)**가 듭니다.  
매번 this를 계산하고 매번 컨텍스트를 새로 만들어야 하니까 시간이 더 걸리고 메모리도 조금 더 쓰게 돼요. 게다가 코드가 복잡해서 call, apply, bind 같은 함수 호출 방법이 섞이면, "어?? 이 함수의 this를 또 바꿨네??" 라고 엔진이 당황합니다. (인간적인 자바스크립트 엔진...)  
그럼 엔진은 이 함수를 최적화해놨다가도
"다시 원래 상태로 돌아가야겠다 (deoptimization)" 하고 최적화를 풀어버려서 성능이 더더욱 떨어지게 됩니다.

    > 💡 deoptimization : "이 함수가 항상 이 컨텍스트에서만 불리네"를 확신할 수 없으면 최적화 포기 해버립니다.
    >
    > deoptimization 로그에 대한 간단한 블로그 글 -> [링크](https://velog.io/@salada17/Deoptimization-%EB%A1%9C%EA%B7%B8-%EB%B6%84%EC%84%9D)

**(2) 화살표 함수는 `this`를 렉시컬하게 캡처합니다**

```javascript
const arrow = () => {
  console.log(this);
};
```

화살표 함수는 함수가 만들어질 때 이미 `this`가 결정됩니다 (바깥 스코프의 `this`). 때문에 실행할 때 컨텍스트를 새로 만들 필요가 없습니다.

- **this 관련 오버헤드가 줄어들어 더 최적화가 쉬워요!**.

특히, **setTimeout**, **Promise**, **map/filter/reduce** 같은 콜백을 쓸 때는 **화살표 함수가 더 가볍고 빠르게 작동** 합니다.

### 그렇다면 실제 성능 차이는?

실험적으로 보면 "간단한 콜백 함수"에서는 화살표 함수가 **미세하게 더 빠를 수 있습니다.**  
하지만 "복잡한 로직", "많은 중첩", "this나 arguments를 많이 사용하는 함수"라면 **차이가 크지 않습니다.**

성능 차이는 대부분 **마이크로초 수준** 이고, 실무에서는 잘 체감되지 않아요. (V8 같은 최신 엔진들은 둘 다 굉장히 빠르게 최적화합니다.)

> **최적화 포인트는** "성능"보다 "this 오버헤드를 줄이고, 코드를 읽기 쉽게 만든다"에 가깝습니다.
>
> - V8 엔진은 `=>` 함수의 `this`를 "closure environment"로 따로 저장합니다.
> - 일반 함수는 실행 시점에 `this`를 "Activation Object"로 새로 만들어야 합니다.
>
> 이 미묘한 차이 덕분에, "짧고 this가 필요한 함수"는 되도록 화살표 함수를 쓰는 게 성능상 유리한 경우가 많아요.
