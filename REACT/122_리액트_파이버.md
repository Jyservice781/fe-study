---
layout: post
title: 자바스크립트의 이벤트
author: haeran
date: 2025-05-28 21:07:00 +0900 
categories: [JAVASCRIPT]
banner:
  image:
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: [Fiber]
---

## 리액트 파이버

리액트 파이버(Fiber)는 **React 16** 에서 도입된 **새로운 리액트의 렌더링 엔진** 입니다. 이전에는 재귀적으로 트리를 탐색하는 Stack 기반 아키텍처였지만, 이는 업데이트 중간에 작업을 중단할 수 없다는 단점이 있었습니다. 파이버는 이 문제를 해결하기 위해 **비동기적이고 인터럽트 가능한 렌더링** 을 지원하는 구조입니다.

React의 렌더링은 보통 다음 **세 단계로 나뉩니다**:

1. **Render Phase (렌더 단계)**
   * 컴포넌트의 함수들이 실행됨
   * 새로운 Virtual DOM과 Fiber 트리 생성
   * 어떤 DOM이 바뀔지를 계산
   * 이 단계는 **비동기적으로 중단/재개 가능**

2. **Commit Phase (커밋 단계)**
   * 계산된 변경 사항을 **진짜 DOM에 적용**
   * 화면에 변화가 생김
   * 이 단계는 **동기적으로 일어나며 중단 불가**

3. **Post-Commit Effects**
   * `useEffect`, `componentDidMount` 같은 **사이드 이펙트 실행**

## 그럼 커밋(commit) phase는 정확히 뭐 하는 구간일까?

> "React가 렌더링 결과를 실제로 DOM에 반영하는 순간"입니다.

### 이때 수행되는 주요 작업

* DOM 조작 (예: 텍스트 바꾸기, 요소 추가/삭제)
* DOM 이벤트 리스너 연결
* `ref` 연결 (`useRef`, `React.createRef`)
* `useLayoutEffect`, `componentDidMount` 실행

## 왜 '커밋(commit)'이라고 부를까?

이름이 "커밋"인 이유는 다음과 같습니다:

* Render Phase에서 많은 작업이 준비되지만 → **아직 실제 변화는 없음**
* Commit Phase에서 **확정된 변경만 적용함** → 마치 Git에서 코드 변경을 확정(commit)하듯

> 즉, "이제 진짜 반영하자!" 라는 순간입니다.

## 시각적 비유

* Render Phase: 영화 촬영 중 편집본 만들기
* Commit Phase: 영화관에서 실제로 상영 시작
* Post-Commit: 관객 반응 분석하고 뒷정리

## 리액트 Fiber 이전 vs 이후 비교

| 항목                  | React 15 이하 (Stack Reconciler) | React 16 이상 (Fiber Reconciler)    |
| ------------------- | ------------------------------ | --------------------------------- |
| **렌더링 방식**          | 재귀 호출 기반 트리 탐색 (동기적)           | 반복적(Iterative) 처리 가능, 비동기적        |
| **작업 단위 분할**        | ❌ 불가능 (전체 렌더링을 한 번에 처리)        | ✅ 작업을 여러 조각으로 나눠 처리               |
| **렌더링 중단/재개**       | ❌ 불가능                          | ✅ 가능 (우선순위 조정 및 작업 재개)            |
| **우선순위 기반 업데이트**    | ❌ 없음                           | ✅ 있음 (urgent vs non-urgent 처리 가능) |
| **에러 처리**           | try/catch에 의존 (전체 앱 중단 가능)     | `Error Boundary`로 컴포넌트 단위 에러 처리   |
| **애니메이션/입력 응답성**    | 끊김 발생 가능                       | 매끄럽게 처리 가능                        |
| **DOM 업데이트 타이밍 제어** | 전체 트리 완료 후 DOM 반영              | commit phase에서 필요한 변경만 반영         |
| **개발자 경험**          | 디버깅 및 최적화 어려움                  | 개발 도구 개선 및 분석 용이                  |

* **이전** 리액트는 마치 **도서관 사서가 한 번에 모든 책을 정리**해야 하는 구조였어요. → 중간에 방문객이 말을 걸어도 무시해야 하고, 정리를 끝내야만 다시 반응할 수 있었죠.
* **Fiber 이후**는 **사서가 책 정리를 잠깐 멈추고 방문객에게 응대한 후 다시 정리**를 계속할 수 있는 구조예요. → 사용자 인터랙션에 훨씬 민첩하게 대응할 수 있습니다.

## 파이버 도입의 영향

* 사용자 경험(UX)이 비약적으로 향상됨 → 대규모 앱에서도 입력 지연 없이 부드럽게 작동
* **동시성 기능** 의 기초가 됨→ React 18의 `startTransition`, `useDeferredValue` 등이 이 기반 위에 존재
* **리액트의 미래 확장성 확보** → 서버 컴포넌트, 스트리밍, 서스펜스 등 고급 기능을 실현할 수 있는 구조로 전환

> 리액트에서 말하는 동시성 기능(Concurrency Features) 은 단순히 "여러 일을 동시에 처리한다"는 의미보다는, 사용자 인터랙션을 더 부드럽고 응답성 있게 만드는 렌더링 전략을 뜻합니다.  
> 렌더링 작업을 중단(suspend) 했다가, **더 중요한 작업(예: 사용자 입력, 애니메이션 등)** 을 먼저 처리하고, 나중에 남은 작업을 다시 이어서 처리할 수 있게 해줍니다.

### 주요 특징

* **작업 분할(Time Slicing)** : 렌더링을 작은 단위로 나눠서, 자바스크립트의 이벤트 루프에서 **브라우저가 필요할 때 작업을 멈췄다가 재개할 수 있음**
* **우선순위 기반 작업 처리** : 긴급한 작업과 덜 긴급한 작업을 구분하여 처리 가능
* **더 나은 오류 처리 및 디버깅 구조** : Error Boundary 등이 작동 가능

## 리액트 파이버 트리

Fiber 구조는 **트리 형태** 로 되어 있으며, 이 트리는 **기존의 Virtual DOM 트리와 매우 유사** 합니다. 하지만 다음과 같은 차이점이 있습니다:

### Fiber Node의 구성

각 Fiber 노드는 다음과 같은 정보를 포함합니다:

* 해당 컴포넌트의 타입과 props
* DOM과의 연결 정보
* 부모, 형제, 자식에 대한 포인터
* 이전 렌더에서의 Fiber 노드 (current)
* side effect 리스트

### 트리 구조의 장점

* **Linked List 형태로 연결**되어 있어, 깊이가 아닌 "작업 순서"로 순회 가능
* **트리 순회 중단 및 재개**가 가능 → 사용자 경험 개선

## 리액트 파이버와 DOM, Virtual DOM의 관계

* **Virtual DOM**은 UI의 상태를 JavaScript 객체로 추상화한 것
* **Fiber**는 Virtual DOM을 **더 세분화된 작업 단위로 나눈 구조**
* **DOM**은 실제 브라우저가 그리는 화면 요소

### 렌더링 과정 요약

1. 상태가 바뀌면 → 새로운 Virtual DOM 생성
2. 이전 Virtual DOM과 비교(Diffing) → Fiber 트리를 통해 작은 단위로 비교
3. 실제 DOM에 반영 → 필요한 최소한의 변경만 적용 (Reconciliation)

즉, Fiber는 Virtual DOM의 "실행 단위", "렌더링 작업 스케줄러"로서 **중간 처리 레이어** 역할을 합니다.

## Fiber가 “diffing”과 “reconciliation”을 직접 수행하는가?

**네, Fiber는 리액트의 diffing과 reconciliation 작업을 수행하는 구조입니다.**

다만, Fiber는 **단순히 차이를 비교(diffing)하는 것 이상으로**,
**렌더링 작업을 "어떻게", "언제", "얼마나 나눠서" 처리할지를 조율하는 엔진**입니다.

### 💡 Diffing

* 새로운 Virtual DOM과 이전 Virtual DOM을 비교해서, **무엇이 바뀌었는지 찾는 과정**
* 예: 텍스트 바뀌었는지? DOM 노드 추가/삭제 되었는지?

### 💡 Reconciliation

* diff 결과를 바탕으로, **React 트리를 업데이트하고 DOM에 반영하기 위한 준비 과정**
* 이 과정에서 **Fiber 트리 생성**, 업데이트 우선순위 결정 등도 수행됨

## Fiber의 역할

Fiber는 Reconciliation 단계에서 핵심 구조입니다:

1. **Virtual DOM을 기반으로 새로운 Fiber 노드 생성**
2. 기존 Fiber 트리와 비교하여, 변경사항을 기록
3. 변경된 노드를 대상으로 **effect list** 생성 (side effect 기록)
4. 최종적으로 DOM 변경은 commit phase에서 반영

## 핵심 요약

| 단계             | 역할                | Fiber의 참여 여부                 |
| -------------- | ----------------- | ---------------------------- |
| Virtual DOM 생성 | 컴포넌트에서 JSX로 트리 생성 | ❌                            |
| Diffing        | 이전 vs 새로운 트리 비교   | ✅ (Fiber가 diff 수행)           |
| Reconciliation | 어떤 변경이 필요한지 판단    | ✅ (Fiber 트리 자체가 이 과정의 핵심)    |
| Commit         | 실제 DOM 업데이트       | ✅ (effect list를 순회하며 DOM 반영) |

## 추가 팁: 왜 Fiber가 필요했을까, 이 과정에서?

기존엔 diffing이 재귀적으로 이뤄졌고, 한번 시작하면 멈출 수 없었어요.
Fiber는 이 작업을 **작은 단위로 쪼개고**, **스케줄링 가능하게** 만들었습니다.

> 즉, **"diffing + reconciliation + 스케줄링"을 모두 담당**하는 구조로 Fiber가 등장한 것입니다.

### 리액트 15 이전은 "재귀 기반" 처리였습니다

* **Stack 기반 재귀 호출**을 통해 트리를 순회했어요
* → 컴포넌트 트리의 깊이에 따라 브라우저의 call stack을 직접 사용
* → 긴 컴포넌트 트리에서는 stack overflow 위험 or 중단 불가능한 문제

| 문제           | 설명                              |
| ------------ | ------------------------------- |
| ❌ 렌더링 중단 불가  | 렌더링은 한 번 시작하면 끝까지 가야 함          |
| ❌ 작업 우선순위 없음 | 모든 업데이트가 동일하게 취급됨               |
| ❌ 메모리 관리 어려움 | 재귀 호출로 인한 stack 사용              |
| ❌ 비동기 대응 어려움 | Suspense, lazy loading 같은 처리 불가 |

Fiber는 **Linked List 기반의 트리 구조**로 재설계되면서 다음을 가능하게 했습니다

* 렌더링 작업을 **작게 나눠서**
* 중단하고 재개할 수 있으며
* 우선순위를 부여하고
* 메모리 효율적인 방식으로 관리 가능
